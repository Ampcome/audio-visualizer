import{jsx as e,jsxs as n}from"react/jsx-runtime";import{useRef as r,useState as t,useMemo as i,useEffect as o,useCallback as c}from"react";import{GUI as a}from"dat.gui";import*as u from"three";import{OrbitControls as l}from"three/examples/jsm/controls/OrbitControls.js";import{EffectComposer as s}from"three/examples/jsm/postprocessing/EffectComposer.js";import{RenderPass as d}from"three/examples/jsm/postprocessing/RenderPass.js";import{UnrealBloomPass as m}from"three/examples/jsm/postprocessing/UnrealBloomPass.js";import{OutputPass as g}from"three/examples/jsm/postprocessing/OutputPass.js";const v=({audioData:c,isListening:v,options:f={}})=>{const{initialQuality:p="medium",initialColors:h,initialBloom:y,showStats:w=!1,enableOrbitControls:x=!0,autoRotate:z=!1,showGui:P=!1,className:b=""}=f,_=r(null),C=r(null),A=r(null),M=r(null),D=r(null),S=r(null),F=r(null),E=r(null),q=r(null),U=r(null),j=r(0),L=r([]),[k,R]=t({x:0,y:0}),[I,W]=t(0),[B,H]=t(p),Q=i((()=>{if("undefined"==typeof window)return{isMobile:!1,isLowEndDevice:!1,initialQuality:p};const e=/iPhone|iPad|iPod|Android/i.test(navigator.userAgent),n=e||(window.navigator.hardwareConcurrency||4)<=4;return{isMobile:e,isLowEndDevice:n,initialQuality:n?"low":p}}),[p]);o((()=>{H(Q.initialQuality)}),[Q.initialQuality]);const T=e=>{switch(e){case"low":return.8;case"high":return 2;default:return 1.2}},G=r({u_time:{value:0},u_amplitude:{value:1.5},u_bass:{value:.5},u_mid:{value:.5},u_treble:{value:.5},u_red:{value:h?.red??1},u_green:{value:h?.green??1},u_blue:{value:h?.blue??1},u_detail:{value:T(B)}}),N=r({threshold:y?.threshold??.5,strength:y?.strength??.3,radius:y?.radius??.8});return o((()=>{if(!_.current)return;G.current.u_detail.value=T(B);const e=new u.Scene;e.background=new u.Color(0),M.current=e;const n=new u.Clock;S.current=n;const r=new u.PerspectiveCamera(45,_.current?.clientWidth/_.current?.clientHeight,.1,1e3);r.position.set(0,-2,14),r.lookAt(0,0,0),D.current=r;try{const e=new u.WebGLRenderer({antialias:!0,alpha:!0,powerPreference:"high-performance",precision:"low"===B?"mediump":"highp"});e.setSize(_.current?.clientWidth,_.current?.clientHeight);const n=()=>{const e=window.devicePixelRatio||1;return Q.isLowEndDevice?Math.min(e,1):"low"===B?Math.min(e,1.5):"medium"===B?Math.min(e,2):e};if(e.setPixelRatio(n()),e.outputColorSpace=u.SRGBColorSpace,_.current.firstChild&&_.current.removeChild(_.current.firstChild),_.current.appendChild(e.domElement),C.current=e,x){const n=new l(r,e.domElement);n.enableDamping=!0,n.dampingFactor=.05,n.enableZoom=!0,n.autoRotate=z,n.update()}}catch(e){}const t=new u.ShaderMaterial({vertexShader:"\n// Simplified noise function based on simplex noise\n// Much more efficient than full Perlin noise implementation\nuniform float u_time;\n\nvec3 mod289(vec3 x)\n    {\n        return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n\nvec4 mod289(vec4 x)\n    {\n        return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n\nvec4 permute(vec4 x)\n    {\n        return mod289(((x*34.0)+10.0)*x);\n    }\n\nvec4 taylorInvSqrt(vec4 r)\n    {\n        return 1.79284291400159 - 0.85373472095314 * r;\n    }\n\nvec3 fade(vec3 t) {\n        return t*t*t*(t*(t*6.0-15.0)+10.0);\n    }\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n    {\n        vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n        vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n        Pi0 = mod289(Pi0);\n        Pi1 = mod289(Pi1);\n        vec3 Pf0 = fract(P); // Fractional part for interpolation\n        vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n        vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n        vec4 iy = vec4(Pi0.yy, Pi1.yy);\n        vec4 iz0 = Pi0.zzzz;\n        vec4 iz1 = Pi1.zzzz;\n\n        vec4 ixy = permute(permute(ix) + iy);\n        vec4 ixy0 = permute(ixy + iz0);\n        vec4 ixy1 = permute(ixy + iz1);\n\n        vec4 gx0 = ixy0 * (1.0 / 7.0);\n        vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n        gx0 = fract(gx0);\n        vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n        vec4 sz0 = step(gz0, vec4(0.0));\n        gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n        gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n        vec4 gx1 = ixy1 * (1.0 / 7.0);\n        vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n        gx1 = fract(gx1);\n        vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n        vec4 sz1 = step(gz1, vec4(0.0));\n        gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n        gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n        vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n        vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n        vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n        vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n        vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n        vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n        vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n        vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n        vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n        g000 *= norm0.x;\n        g010 *= norm0.y;\n        g100 *= norm0.z;\n        g110 *= norm0.w;\n        vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n        g001 *= norm1.x;\n        g011 *= norm1.y;\n        g101 *= norm1.z;\n        g111 *= norm1.w;\n\n        float n000 = dot(g000, Pf0);\n        float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n        float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n        float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n        float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n        float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n        float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n        float n111 = dot(g111, Pf1);\n\n        vec3 fade_xyz = fade(Pf0);\n        vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n        vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n        float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n        return 2.2 * n_xyz;\n    }\n\n// Uniforms\nuniform float u_amplitude;\nuniform float u_bass;\nuniform float u_mid;\nuniform float u_treble;\nuniform float u_detail;\n\n// Varying variables to pass to fragment shader\nvarying vec3 vNormal;\n\nvoid main() {\n  // Calculate noise based on position and time\n  // Use u_detail to control level of detail (lower = better performance)\n  float noise = 3.0 * pnoise(position + u_time, vec3(10.0));\n  \n  // Calculate displacement based on audio frequencies\n  float bassDisplacement = u_bass * noise * 0.5;\n  float midDisplacement = u_mid * noise * 0.3;\n  float trebleDisplacement = u_treble * noise * 0.2;\n  \n  // Combine displacements with amplitude control\n  float displacement = u_amplitude * (bassDisplacement + midDisplacement + trebleDisplacement) * (noise / 10.);\n  \n  // Apply displacement along normal direction\n  vec3 newPosition = position + normal * displacement;\n  \n  // Pass normal to fragment shader\n  vNormal = normal;\n  \n  // Set final position\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}\n",fragmentShader:"\n// Color uniforms\nuniform float u_red;\nuniform float u_green;\nuniform float u_blue;\n\n// Varying variables received from vertex shader\nvarying vec3 vNormal;\n\nvoid main() {\n  // Apply color based on uniform values\n  gl_FragColor = vec4(vec3(u_red, u_green, u_blue), 1.0);\n}\n",wireframe:!0,uniforms:G.current}),i=(e=>{switch(e){case"low":return 20;case"high":return 40;default:return 30}})(B),o=new u.IcosahedronGeometry(4,Math.min(i,30));o.index&&(o.index.needsUpdate=!0),o.attributes.position.needsUpdate=!0,o.attributes.normal.needsUpdate=!0;const c=new u.Mesh(o,t);e.add(c),A.current=c;const v=new d(M.current,D.current),f=new m(new u.Vector2(_.current?.clientWidth,_.current?.clientHeight),N.current.strength,N.current.radius,N.current.threshold);E.current=f;const p=new g;if(C.current){const e=new s(C.current);e.addPass(v),e.addPass(f),e.addPass(p),e.setSize(_.current?.clientWidth,_.current?.clientHeight),F.current=e}if(P){const e=new a;q.current=e;const n=e.addFolder("Colors");n.add(G.current.u_red,"value",0,1).name("Red"),n.add(G.current.u_green,"value",0,1).name("Green"),n.add(G.current.u_blue,"value",0,1).name("Blue"),n.open();const r=e.addFolder("Bloom");r.add(N.current,"threshold",0,1).name("Threshold").onChange((e=>{E.current&&(E.current.threshold=e)})),r.add(N.current,"strength",0,3).name("Strength").onChange((e=>{E.current&&(E.current.strength=e)})),r.add(N.current,"radius",0,1).name("Radius").onChange((e=>{E.current&&(E.current.radius=e)})),r.open();const t=e.addFolder("Settings");t.add({quality:B},"quality",["low","medium","high"]).name("Quality").onChange((e=>{H(e)})),t.open()}const h=()=>{if(!_.current||!C.current||!D.current)return;const e=_.current.clientWidth,n=_.current.clientHeight;D.current.aspect=e/n,D.current.updateProjectionMatrix(),C.current.setSize(e,n),F.current&&F.current.setSize(e,n)};return window.addEventListener("resize",h),()=>{window.removeEventListener("resize",h),U.current&&(cancelAnimationFrame(U.current),U.current=null),C.current&&_.current&&_.current.removeChild(C.current.domElement),A.current&&(A.current.geometry.dispose(),A.current.material.dispose()),q.current&&q.current.destroy()}}),[_.current?.clientWidth,_.current?.clientHeight,B,Q.isLowEndDevice,x,z,P,h,y]),o((()=>{const e=e=>{const n=window.innerWidth/2,r=window.innerHeight/2;R({x:(e.clientX-n)/100,y:(e.clientY-r)/100})};return window.addEventListener("mousemove",e),()=>{window.removeEventListener("mousemove",e)}}),[]),o((()=>{if(!(M.current&&D.current&&S.current&&C.current&&A.current))return;const e=1e3/(e=>{switch(e){case"low":return 30;case"high":return 60;default:return 45}})(B),n=()=>{if(U.current=requestAnimationFrame(n),!(D.current&&M.current&&S.current&&C.current&&G.current&&A.current))return;const r=performance.now(),t=r-j.current;if(!(t<e)){if(w){const e=1e3/t;if(L.current.push(e),L.current.length>30&&L.current.shift(),L.current.length%10==0){const e=L.current.reduce(((e,n)=>e+n),0)/L.current.length;W(Math.round(e))}}D.current.position.x+=.05*(k.x-D.current.position.x),D.current.position.y+=.5*(-k.y-D.current.position.y),D.current.lookAt(M.current.position),G.current.u_time.value=S.current.getElapsedTime();try{if(c&&v&&c.length>0)try{const e=c.length,n=Math.max(1,Math.floor(e/64)),r=Math.floor(.1*e);let t=0;for(let e=0;e<r;e+=n)t+=c[e]||0;const i=t/Math.ceil(r/n)||0,o=r,a=Math.floor(.5*e);let u=0;for(let e=o;e<a;e+=n)u+=c[e]||0;const l=u/Math.ceil((a-o)/n)||0,s=a;let d=0;for(let r=s;r<e;r+=n)d+=c[r]||0;const m=d/Math.ceil((e-s)/n)||0,g=.7;G.current.u_bass.value=G.current.u_bass.value*(1-g)+i/255*7.5*g,G.current.u_mid.value=G.current.u_mid.value*(1-g)+l/255*7.5*g,G.current.u_treble.value=G.current.u_treble.value*(1-g)+m/255*7.5*g;const v=(i+l+m)/3;G.current.u_amplitude.value=G.current.u_amplitude.value*(1-g)+(.5+v/255*7.5)*g}catch(e){const n=S.current.getElapsedTime();G.current.u_amplitude.value=1+.3*Math.sin(.2*n)}else G.current.u_amplitude.value=0,G.current.u_bass.value=0,G.current.u_mid.value=0,G.current.u_treble.value=0,A.current&&(A.current.rotation.y+=.001);if(A.current&&(A.current.rotation.y+=.001),F.current)try{F.current.render()}catch(e){C.current.render(M.current,D.current)}else C.current.render(M.current,D.current);j.current=r}catch(e){}}};return U.current=requestAnimationFrame(n),()=>{U.current&&(cancelAnimationFrame(U.current),U.current=null)}}),[k,c,v,B,w]),e("div",{ref:_,"aria-label":"3D Audio Visualizer",style:{width:"100%",height:"100%",overflow:"hidden",backgroundColor:"#000",position:"relative",...f?.containerStyle},className:b,children:w&&n("div",{style:{position:"absolute",top:"8px",right:"8px",backgroundColor:"rgba(0, 0, 0, 0.5)",color:"white",padding:"8px",borderRadius:"4px"},children:[n("p",{children:["FPS: ",I]}),n("p",{children:["Quality: ",B]})]})})},f=()=>{const[e,n]=t(!1),[i,a]=t((()=>{const e=new Uint8Array(128);for(let n=0;n<e.length;n++)e[n]=Math.floor(40+20*Math.sin(.1*n));return e})),[u,l]=t(null),s=r(null),d=r(null),m=r(null),g=r(null),v=r(null),f=c((()=>{g.current&&(cancelAnimationFrame(g.current),g.current=null),m.current&&(m.current.getTracks().forEach((e=>e.stop())),m.current=null),s.current&&"closed"!==s.current.state&&(s.current.close().catch(console.error),s.current=null),d.current=null,v.current=null}),[]);o((()=>("undefined"!=typeof window&&(void 0!==window.AudioContext||void 0!==window.webkitAudioContext)&&navigator.mediaDevices&&navigator.mediaDevices.getUserMedia||l("Your browser does not support the required audio APIs"),f)),[f]);return{isListening:e,audioData:i,error:u,startListening:c((async()=>{try{if(f(),l(null),"undefined"==typeof window||void 0===window.AudioContext&&void 0===window.webkitAudioContext)throw new Error("Your browser does not support Web Audio API");if(!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)throw new Error("Media Devices API not supported in this browser");const e=await navigator.mediaDevices.getUserMedia({audio:!0});m.current=e;const r=new(window.AudioContext||window.webkitAudioContext);s.current=r,"suspended"===r.state&&await r.resume();const t=r.createAnalyser();t.fftSize=512,t.smoothingTimeConstant=.7,t.minDecibels=-90,t.maxDecibels=-10,d.current=t;r.createMediaStreamSource(e).connect(t);const i=new Uint8Array(t.frequencyBinCount);v.current=i,t.getByteFrequencyData(i),a(new Uint8Array(i));const o=()=>{if(d.current&&v.current)try{d.current.getByteFrequencyData(v.current);const e=new Uint8Array(v.current);a(e),g.current=requestAnimationFrame(o)}catch(e){g.current&&(cancelAnimationFrame(g.current),setTimeout((()=>{g.current=requestAnimationFrame(o)}),100))}};g.current=requestAnimationFrame(o),n(!0)}catch(e){f();const n=e instanceof Error?e.message:"Failed to access microphone";l(n)}}),[f]),stopListening:c((()=>{f(),n(!1);const e=new Uint8Array(128);for(let n=0;n<e.length;n++)e[n]=Math.floor(30+15*Math.sin(.1*n));a(e)}),[f])}};export{v as AudioVisualizer,f as useAudioListener};
//# sourceMappingURL=index.esm.js.map
